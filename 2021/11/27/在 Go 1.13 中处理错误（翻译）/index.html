<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/avatar.jpeg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/avatar.jpeg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/avatar.jpeg">
  <link rel="mask-icon" href="/images/avatar.jpeg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"forgetall.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Working with Errors in Go 1.13Damien Neil and Jonathan Amsterdam17 October 2019 介绍Go 将 error 作为 values 已经很好的为我们服务了数十年。尽管标准库对 errors 的支持很少——只有errors.New和fmt.Errorf函数，会产生只包含消息的 errors——内置的 error interfa">
<meta property="og:type" content="article">
<meta property="og:title" content="在 Go 1.13 中处理错误（翻译）">
<meta property="og:url" content="https://forgetall.github.io/2021/11/27/%E5%9C%A8%20Go%201.13%20%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/index.html">
<meta property="og:site_name" content="LJ的Blog">
<meta property="og:description" content="Working with Errors in Go 1.13Damien Neil and Jonathan Amsterdam17 October 2019 介绍Go 将 error 作为 values 已经很好的为我们服务了数十年。尽管标准库对 errors 的支持很少——只有errors.New和fmt.Errorf函数，会产生只包含消息的 errors——内置的 error interfa">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-11-26T16:00:44.000Z">
<meta property="article:modified_time" content="2021-11-27T01:02:58.566Z">
<meta property="article:author" content="LJ">
<meta property="article:tag" content="go">
<meta property="article:tag" content="翻译">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://forgetall.github.io/2021/11/27/%E5%9C%A8%20Go%201.13%20%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>在 Go 1.13 中处理错误（翻译） | LJ的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LJ的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学海无涯苦做舟</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://forgetall.github.io/2021/11/27/%E5%9C%A8%20Go%201.13%20%E4%B8%AD%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="LJ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJ的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          在 Go 1.13 中处理错误（翻译）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-11-27 00:00:44 / 修改时间：09:02:58" itemprop="dateCreated datePublished" datetime="2021-11-27T00:00:44+08:00">2021-11-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BF%BB%E8%AF%91/" itemprop="url" rel="index"><span itemprop="name">翻译</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BF%BB%E8%AF%91/go/" itemprop="url" rel="index"><span itemprop="name">go</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Working-with-Errors-in-Go-1-13"><a href="#Working-with-Errors-in-Go-1-13" class="headerlink" title="Working with Errors in Go 1.13"></a>Working with Errors in Go 1.13</h2><p><em>Damien Neil and Jonathan Amsterdam</em><br><em>17 October 2019</em></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Go 将 error 作为 values 已经很好的为我们服务了数十年。尽管标准库对 errors 的支持很少——只有<code>errors.New</code>和<code>fmt.Errorf</code>函数，会产生只包含消息的 errors——内置的 error interface 允许 Go 程序猿添加他们想要的任何信息。它所需要的只是实现一个<code>Error</code>方法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">    Err   error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Query + <span class="string">&quot;: &quot;</span> + e.Err.Error() &#125;</span><br></pre></td></tr></table></figure>

<p>像这样的 Error 类型无处不在，而且他们存储的信息千差万别，从时间戳到文件名到服务器地址。通常，该信息包括另一个较低级的 error 以提供额外的上下文。</p>
<span id="more"></span>

<p>这种一个错误包含另一个的模式在 Go 代码中如此普遍，经过<a target="_blank" rel="noopener" href="https://golang.org/issue/29934">广泛讨论</a>，Go 1.13 添加了对他的明确支持。本文描述了标准库中提供支持的新增内容：<code>errors</code>包中的三个新函数和新增的格式化动词<code>fmt.Errorf</code>。</p>
<p>在描述这些变化的细节之前，让我们再看一下在以前的版本如何检查 errors 和构造 error 。</p>
<h3 id="Go-1-13-之前的错误"><a href="#Go-1-13-之前的错误" class="headerlink" title="Go 1.13 之前的错误"></a>Go 1.13 之前的错误</h3><h4 id="检查错误"><a href="#检查错误" class="headerlink" title="检查错误"></a>检查错误</h4><p>Go 错误是值。程序以集中方式根据这些值做出决策。最常用的是比较<code>error</code>和<code>nil</code>去查看操作是否失败了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="comment">// something went wrong</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时我们将<code>error</code>和已知的预定值比较，去查看是否发生了特定的<code>error</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err == ErrNotFound &#123;</span><br><span class="line">    <span class="comment">// something wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>error</code>值也许是满足语言定义的<code>error</code>接口的任何类型。程序可以用类型断言或者类型切换将<code>error</code>视为更具体的类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NotFoundError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *NotFoundError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123; <span class="keyword">return</span> e.Name + <span class="string">&quot;: not found&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> e, ok := err.(*NotFoundError); ok &#123;</span><br><span class="line">    <span class="comment">// e.Name wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="添加信息"><a href="#添加信息" class="headerlink" title="添加信息"></a>添加信息</h4><p>通常，函数在向其添加信息时将<code>error</code>传递到调用堆栈上，就像当<code>error</code>发生时发生了什么的简短描述。一种简单的方式实现是构造一个新的<code>error</code>包括了前一个的文字。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %v&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>fmt.Errorf</code>创建一个新的<code>error</code>丢弃了所有来自原始<code>error</code>的东西除了文字。就像我们在上面看到的<code>QueryError</code>，也许我们有时想要定义一个新的<code>error</code>类型包含底层错误，保留它以供代码检查。再看一下<code>QueryError</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> QueryError <span class="keyword">struct</span> &#123;</span><br><span class="line">    Query <span class="keyword">string</span></span><br><span class="line">    Err   error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序可以查看<code>*QueryError</code>内部的值去根据底层错误做决策。你有时会看到这作为<code>unwrapping</code>（解包）错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission &#123;</span><br><span class="line">    <span class="comment">// query failed because of a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库中的<code>os.PathError</code>类型是另一个一个<code>error</code>包含另一个的例子。</p>
<h3 id="在-Go-1-13-中的错误"><a href="#在-Go-1-13-中的错误" class="headerlink" title="在 Go 1.13 中的错误"></a>在 Go 1.13 中的错误</h3><h4 id="展开方法（The-Unwrap-method）"><a href="#展开方法（The-Unwrap-method）" class="headerlink" title="展开方法（The Unwrap method）"></a>展开方法（The Unwrap method）</h4><p>Go 1.13 介绍了简化处理错误包含其他错误的<code>errors</code>和<code>fmt</code>标准库包的新特性。其中最重要的是约定而不是变更：一个错误包含其他的要实现<code>Unwrap</code>方法返回底层错误。如果<code>e1.Unwrap()</code>返回了<code>e2</code>，那么我们说<code>e1 wraps e2</code>，然后你可以<code>unwrap</code> e1 去获得 e2。</p>
<p>按照这个预定，我们可以给出上面的<code>QueryError</code>类型一个<code>Unwrap</code>方法返回他包含的错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *QueryError)</span> <span class="title">Unwrap</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> e.Err &#125;</span><br></pre></td></tr></table></figure>

<p>解包<code>error</code>的结果也许他自身也有一个<code>Unwrap</code>方法，我们按顺序调用由重复展开错误链产生的错误。（ we call the sequence of errors produced by repeated unwrapping the <em>error chain</em>.）</p>
<h4 id="使用-Is-和-As-检查错误"><a href="#使用-Is-和-As-检查错误" class="headerlink" title="使用 Is 和 As 检查错误"></a>使用 Is 和 As 检查错误</h4><p>Go 1.13 <code>errors</code>包包含了两个检查错误的新函数：<code>Is</code>和<code>As</code>。</p>
<p><code>errors.Is</code>函数将<code>error</code>和值比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Similar to:</span></span><br><span class="line"><span class="comment">//   if err == ErrNotFound &#123; … &#125;</span></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrNotFound) &#123;</span><br><span class="line">    <span class="comment">// something wasn&#x27;t found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>As</code>函数测试<code>error</code>是否是特定类型：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Similar to:</span></span><br><span class="line"><span class="comment">//   if e, ok := err.(*QueryError); ok &#123; … &#125;</span></span><br><span class="line"><span class="keyword">var</span> e *QueryError</span><br><span class="line"><span class="comment">// Note: *QueryError is the type of the error.</span></span><br><span class="line"><span class="keyword">if</span> errors.As(err, &amp;e) &#123;</span><br><span class="line">    <span class="comment">// err is a *QueryError, and e is set to the error&#x27;s value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个最简单的栗子中，<code>errors.Is</code>函数表现的像是和 sentinel error 比较，<code>errors.As</code>函数表现的像是类型断言。当在处理包装错误（wrapped errors）时，然而，这些函数会考虑链中的所有错误。让我们再看一下上面解包一个<code>QueryError</code>去检查底层错误的代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission &#123;</span><br><span class="line">    <span class="comment">// query failed because of a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>errors.Is</code>函数，我们可以像下面这样写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> errors.Is(err, ErrPermission) &#123;</span><br><span class="line">    <span class="comment">// err, or some error that it wraps, is a permission problem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>errors</code>包也包括了一个新的<code>Unwrap</code>函数，返回调用<code>error</code>的<code>Unwrap</code>方法的结果，或者<code>nil</code>当<code>error</code>没有<code>Unwrap</code>方法时。通常使用<code>errors.Is</code>或者<code>errors.As</code>方法更好，但是，这些函数会在单次调用中检查整个链。</p>
<p>注意：尽管将指针指向指针可能会感觉怪怪的，在这种情况下是对的。把他想象成一个指向错误类型的值，在这种情况下事情就是这样，他返回的<code>error</code>是一个指针类型</p>
<h4 id="使用-w-包装-errors"><a href="#使用-w-包装-errors" class="headerlink" title="使用 %w 包装 errors"></a>使用 %w 包装 errors</h4><p>像以前提到的，用<code>fmt.Errorf</code>函数向<code>error</code>中添加信息是很普遍的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %v&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Go 1.13 中，<code>fmt.Errorf</code>函数支持新的<code>%w</code>。当这个动词出现时，由<code>fmt.Errorf</code>返回的<code>error</code>将有一个<code>Unwrap</code>方法返回<code>%w</code>参数，这肯定是一个<code>error</code>。在其他方面，<code>%w</code>和<code>%v</code>相同。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// Return an error which unwraps to err.</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;decompress %v: %w&quot;</span>, name, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>%w</code>包装<code>error</code>使其可用于<code>errors.Is</code>和<code>errors.As</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">err := fmt.Errorf(<span class="string">&quot;access denied: %w&quot;</span>, ErrPermission)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, ErrPermission) ...</span><br></pre></td></tr></table></figure>

<h4 id="是否包装"><a href="#是否包装" class="headerlink" title="是否包装"></a>是否包装</h4><p>当向<code>error</code>添加上下文时，无论是使用<code>fmt.Errorf</code>还是通过自定义实现，你都需要决定新<code>error</code>是否应该包装原始的。这个问题没有唯一的答案，他取决于被创建的<code>error</code>的上下文。包装<code>error</code>将其暴露给调用者。当这么做会暴露实现细节时不要包装<code>error</code>。</p>
<p>作为一个栗子，想象一下一个<code>Parse</code>函数从<code>io.Reader</code>读取复杂的数据结构。如果<code>error</code>发生了，我们希望报告在哪一行哪一列发生了。如果从<code>io.Reader</code>读取时发生错误，我们想要包装<code>error</code>以便允许检查底层问题。既然调用者为函数提供了<code>io.Reader</code>，那么将由他产生的<code>error</code>暴露是有意义的。</p>
<p>相比之下，一个对数据库发起多次调用的函数也许不应该返回<code>error</code>，因为解包的结果是这些调用中的一个。如果函数使用的数据库是实现细节，那么暴露这些错误违反了抽象（原则，从具体问题中，提取出具有共性的模式，再使用通用的解决方法加以处理）。例如，<code>pkg</code>包中的<code>LookupUser</code>函数使用<code>Go</code>的<code>database/sql</code>包，那么他也许会碰到<code>sql.ErrNoRows</code>错误。如果你使用<code>fmt.Errorf(&quot;accessing DB: %v&quot;, err)</code>返回一个<code>error</code>，那么调用者无法查看内部发现<code>sql.ErrNoRows</code>。但是如果函数使用<code>fmt.Errorf(&quot;accessing DB: %w&quot;, err)</code>，那么调用者可以合理的这么写：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">err := pkg.LookupUser(...)</span><br><span class="line"><span class="keyword">if</span> errors.Is(err, sql.ErrNoRows) …</span><br></pre></td></tr></table></figure>

<p>此时，如果你不想中断客户端，该函数必须始终返回<code>sql.ErrNoRows</code>，即使你切换到一个不同的数据库包。换句话说，包装<code>error</code>使得那个<code>error</code>变成你的 API 的一部分。如果你不想承诺在未来将那个<code>error</code>作为你 API 的一部分，那么你不应该包装<code>error</code>。</p>
<p>很重要的一点是无论你是否包装，<code>error</code>文字要是一样的。试图理解<code>error</code>的人无论用哪种方式都将获得相同的信息。包装的选择是关于给程序额外的信息让他们可以做出更明智的决定，或者保留该信息以保留抽象层。</p>
<h3 id="使用-Is-和-As-方法自定义-error"><a href="#使用-Is-和-As-方法自定义-error" class="headerlink" title="使用 Is 和 As 方法自定义 error"></a>使用 Is 和 As 方法自定义 error</h3><p><code>errors.Is</code>方法为了匹配目标值检查链中的每一个<code>error</code>。在默认情况下，如果两者相等那么<code>error</code>匹配目标。此外，链中的<code>error</code>也许会通过实现<code>Is</code>声明他匹配目标。</p>
<p>举个例子，这个<code>error</code>灵感来自<a target="_blank" rel="noopener" href="https://commandcenter.blogspot.com/2017/12/error-handling-in-upspin.html">Upspin error package</a>，他将<code>error</code>与模板比较，仅考虑模板中的非零字段：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Error <span class="keyword">struct</span> &#123;</span><br><span class="line">    Path <span class="keyword">string</span></span><br><span class="line">    User <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *Error)</span> <span class="title">Is</span><span class="params">(target error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    t, ok := target.(*Error)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (e.Path == t.Path || t.Path == <span class="string">&quot;&quot;</span>) &amp;&amp;</span><br><span class="line">           (e.User == t.User || t.User == <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> errors.Is(err, &amp;Error&#123;User: <span class="string">&quot;someuser&quot;</span>&#125;) &#123;</span><br><span class="line">    <span class="comment">// err&#x27;s User field is &quot;someuser&quot;.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>errors.As</code>函数在出现时类似的参考<code>As</code>方法。</p>
<h3 id="错误和包-APIs"><a href="#错误和包-APIs" class="headerlink" title="错误和包 APIs"></a>错误和包 APIs</h3><p>一个返回错误的包（大多数都应该这么做）应该描述程序员可能依赖的那些错误属性。一个设计良好的包也会避免返回不应该依赖的错误的属性。</p>
<p>最简单的规范操作是说操作成功还是失败，个别的返回 nil 或 非 nil 错误值。在大多数情况下，不需要进一步的信息。</p>
<p>如果我们希望函数返回可识别的错误条件，类似“未发现项目，” 我们可能会返回包装预定值的<code>error</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrNotFound = errors.New(<span class="string">&quot;not found&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// FetchItem returns the named item.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If no item with the name exists, FetchItem returns an error</span></span><br><span class="line"><span class="comment">// wrapping ErrNotFound.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FetchItem</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="params">(*Item, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> itemNotFound(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;%q: %w&quot;</span>, name, ErrNotFound)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一些其他存在的模式，提供可供调用者从语义上检查的错误，类似直接返回一个预定值，一个指定的类型，或者可以被判断函数（predicate function）检查的值。</p>
<p>在所有情况下，都要注意不要将内部细节暴露给用户。正如我们在上面“是否要包装”中提到的那样，当你返回一个来自其他包的<code>error</code>，你应该将<code>error</code>转化为一个不会暴露底层<code>error</code>的格式，除非你愿意承诺在未来返回这个特定错误。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(filename)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// The *os.PathError returned by os.Open is an internal detail.</span></span><br><span class="line">    <span class="comment">// To avoid exposing it to the caller, repackage it as a new</span></span><br><span class="line">    <span class="comment">// error with the same text. We use the %v formatting verb, since</span></span><br><span class="line">    <span class="comment">// %w would permit the caller to unwrap the original *os.PathError.</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果函数被定义成返回一个包装了一些预定值或类型的<code>error</code>，不要直接返回底层的<code>error</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ErrPermission = errors.New(<span class="string">&quot;permission denied&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DoSomething returns an error wrapping ErrPermission if the user</span></span><br><span class="line"><span class="comment">// does not have permission to do something.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DoSomething</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !userHasPermission() &#123;</span><br><span class="line">        <span class="comment">// If we return ErrPermission directly, callers might come</span></span><br><span class="line">        <span class="comment">// to depend on the exact error value, writing code like this:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); err == pkg.ErrPermission &#123; … &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// This will cause problems if we want to add additional</span></span><br><span class="line">        <span class="comment">// context to the error in the future. To avoid this, we</span></span><br><span class="line">        <span class="comment">// return an error wrapping the sentinel so that users must</span></span><br><span class="line">        <span class="comment">// always unwrap it:</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//     if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) &#123; ... &#125;</span></span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;%w&quot;</span>, ErrPermission)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>尽管我们讨论的更改仅包含三个函数和一个格式化动词，我们希望他们对改进 Go 程序中错误的处理方式有很大的帮助。我们期望提供额外上下文的包装将变得普遍，帮助程序做出更好的决策和帮助程序员更快的找到 bug。</p>
<p>正如 Russ Cox 在他的 <a target="_blank" rel="noopener" href="https://go.dev/blog/experiment">GopherCon 2019</a> 主题演讲中所说，在 Go 2 的道路上，我们进行实验、简化和发布。现在我们已经发布了这些更改，我们期待接下来的实验。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/go/" rel="tag"># go</a>
              <a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"># 翻译</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/21/%E9%94%99%E8%AF%AF%E6%98%AF%E5%80%BC%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/" rel="prev" title="Errors are values（翻译）">
      <i class="fa fa-chevron-left"></i> Errors are values（翻译）
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/02/26/%E4%BD%BF%E7%94%A8%20redis%20%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" rel="next" title="使用 redis 实现分布式锁">
      使用 redis 实现分布式锁 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Working-with-Errors-in-Go-1-13"><span class="nav-number">1.</span> <span class="nav-text">Working with Errors in Go 1.13</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Go-1-13-%E4%B9%8B%E5%89%8D%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">1.2.</span> <span class="nav-text">Go 1.13 之前的错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E9%94%99%E8%AF%AF"><span class="nav-number">1.2.1.</span> <span class="nav-text">检查错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0%E4%BF%A1%E6%81%AF"><span class="nav-number">1.2.2.</span> <span class="nav-text">添加信息</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8-Go-1-13-%E4%B8%AD%E7%9A%84%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.</span> <span class="nav-text">在 Go 1.13 中的错误</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%95%E5%BC%80%E6%96%B9%E6%B3%95%EF%BC%88The-Unwrap-method%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">展开方法（The Unwrap method）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Is-%E5%92%8C-As-%E6%A3%80%E6%9F%A5%E9%94%99%E8%AF%AF"><span class="nav-number">1.3.2.</span> <span class="nav-text">使用 Is 和 As 检查错误</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-w-%E5%8C%85%E8%A3%85-errors"><span class="nav-number">1.3.3.</span> <span class="nav-text">使用 %w 包装 errors</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%AF%E5%90%A6%E5%8C%85%E8%A3%85"><span class="nav-number">1.3.4.</span> <span class="nav-text">是否包装</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Is-%E5%92%8C-As-%E6%96%B9%E6%B3%95%E8%87%AA%E5%AE%9A%E4%B9%89-error"><span class="nav-number">1.4.</span> <span class="nav-text">使用 Is 和 As 方法自定义 error</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%92%8C%E5%8C%85-APIs"><span class="nav-number">1.5.</span> <span class="nav-text">错误和包 APIs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">1.6.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="LJ"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">LJ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/ForgetAll" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;ForgetAll" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://blankj.com/" title="https:&#x2F;&#x2F;blankj.com&#x2F;" rel="noopener" target="_blank">blankj-开源达人</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LJ</span>
</div>
  <div class="powered-by">书山有路勤为径
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
