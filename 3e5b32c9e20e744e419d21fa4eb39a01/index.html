<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"forgetall.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="写在前面前段时间写了一篇MVP初尝试，由于当时只是刚接触，只是简单的实现，还有很多问题没想明白。关于内存泄露这事是本文着重要谈的一点，同时本文是我在看了很多关于Java和Android内存泄露分析的文章之后的所得。 概述在了解MVP引起的内存泄露问题之前，我们首先要理解在Android中内存泄露是啥玩意？简单的讲内存泄漏就是** 本该被释放内存的对象没有被释放 *。最近也和同学@iamxiarui">
<meta property="og:type" content="article">
<meta property="og:title" content="Android内存泄露浅析">
<meta property="og:url" content="https://forgetall.github.io/3e5b32c9e20e744e419d21fa4eb39a01/index.html">
<meta property="og:site_name" content="LJ的Blog">
<meta property="og:description" content="写在前面前段时间写了一篇MVP初尝试，由于当时只是刚接触，只是简单的实现，还有很多问题没想明白。关于内存泄露这事是本文着重要谈的一点，同时本文是我在看了很多关于Java和Android内存泄露分析的文章之后的所得。 概述在了解MVP引起的内存泄露问题之前，我们首先要理解在Android中内存泄露是啥玩意？简单的讲内存泄漏就是** 本该被释放内存的对象没有被释放 *。最近也和同学@iamxiarui">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1976147-b32d9b0150f26875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1976147-b28be23de6ef74f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1976147-31151e6a1da05a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1976147-ceb78f52493dfb1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1976147-525112dc21036ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1976147-c50908147483dc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2016-10-02T03:15:31.000Z">
<meta property="article:modified_time" content="2022-03-09T08:44:27.484Z">
<meta property="article:author" content="LJ">
<meta property="article:tag" content="Android">
<meta property="article:tag" content="内存泄漏">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1976147-b32d9b0150f26875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">

<link rel="canonical" href="https://forgetall.github.io/3e5b32c9e20e744e419d21fa4eb39a01/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Android内存泄露浅析 | LJ的Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LJ的Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">学海无涯苦做舟</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://forgetall.github.io/3e5b32c9e20e744e419d21fa4eb39a01/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="LJ">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LJ的Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Android内存泄露浅析
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-10-02 11:15:31" itemprop="dateCreated datePublished" datetime="2016-10-02T11:15:31+08:00">2016-10-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-09 16:44:27" itemprop="dateModified" datetime="2022-03-09T16:44:27+08:00">2022-03-09</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>前段时间写了一篇<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/6d42bf4efe16">MVP初尝试</a>，由于当时只是刚接触，只是简单的实现，还有很多问题没想明白。关于内存泄露这事是本文着重要谈的一点，同时本文是我在看了很多关于Java和Android内存泄露分析的文章之后的所得。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在了解MVP引起的内存泄露问题之前，我们首先要理解在Android中内存泄露是啥玩意？简单的讲内存泄漏就是** 本该被释放内存的对象没有被释放 *<em>。最近也和同学<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/86f25f8b198b/latest_articles">@iamxiarui</a>就内存泄露这个问题进行了一些讨论，最后发现要搞清楚这个东西，还要从Java层上找原因。学习Android的同学都应该知道，Java这门语言有一个垃圾回收器，一般来说我们是无需关心内存回收的问题。但是玩过LOL或者DOTA的同学都知道，一个猪队友和一个神对手究竟哪个威胁更大一些，我们不能当GC的</em>队友，所以多了解一些这玩意吧。</p>
<p>在C++中会有析构函数这个概念，在C++中销毁对象必须用到这个函数，如此说来C++中是可以手动释放内存的。你可能会说Java中不也有finalize()方法吗？是的，是有这东西，让我们来看看这玩意。</p>
<h4 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h4><span id="more"></span>
<p>关于这货，在《Thinking in java》里说：</p>
<ul>
<li>不能指望finalize()。</li>
</ul>
<p>在《effective java》里说：</p>
<ul>
<li>避免使用终结方法：终结方法通常是不可预测的，也是很危险的，一般情况下是不必要的。</li>
</ul>
<p>至于为什么那么描述finalize()方法，原因如下：</p>
<blockquote>
<p>终结方法的缺点在于不能保证会被及时的执行。</p>
</blockquote>
<p>你以为这就完了？《effective java》中还有一段描述：</p>
<blockquote>
<p>Java语言规范不仅不保证终结方法会被及时的执行，而且根本就不保证它们会被执行。</p>
</blockquote>
<p>那么在很多由于生命周期所引发的内存泄漏问题上，我们就不能想着手动释放内存了，因为我们需要“及时”的释放内存，但是finalize()并不能满足我们的需求。那么我们应该想一些办法，“告诉”GC：我这是可以回收的，请回收这部分内存吧！</p>
<p>那么问题来了：我们该用怎样的方式告诉GC，并且让GC可以回收这部分内存呢？这是我们今天主要要解决的问题，但是我们首先要弄明白的是Java中关于内存的一些事。</p>
<h2 id="Java内存分配策略"><a href="#Java内存分配策略" class="headerlink" title="Java内存分配策略"></a>Java内存分配策略</h2><p>Java程序运行时的内存分配策略有三种，分别是静态分配，栈式分配和堆式分配。对应的，三种存储策略使用的内存空间主要分别是静态存储区、栈区和堆区。</p>
<ul>
<li>静态存储区：编译时就分配好，在程序整个运行期间都存在。主要存放静态数据和常量。</li>
<li>栈区：当方法执行时，会在栈去内存中创建方法体内部的局部变量，方法结束后自动释放内存。</li>
<li>堆区：通常存放new出来的对象，由Java垃圾回收器管理内存的回收。</li>
</ul>
<p>很明显，本文需要关注的就是堆区了，堆内存用于存放对象实例，至于堆内如何划分，如何存放对象，这些东西都由具体的实现来决定。</p>
<h2 id="Java内存管理"><a href="#Java内存管理" class="headerlink" title="Java内存管理"></a>Java内存管理</h2><p>在我们对Java内存管理作了解之前我们需要抓住这个问题的核心：</p>
<ul>
<li>如何判定可回收对象</li>
<li>采用什么策略</li>
</ul>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>首先介绍一种用于说明垃圾收集工作方式的策略，** 引用计数 **：</p>
<p>每个对象都含有一个引用计数器，当有引用连接至对象时，引用计数加1。当引用离开作用域或者被置为null时，引用计数减1。垃圾回收器在遍历所有对象时发现引用计数为0便释放其内存。这种策略很难处理循环引用的情况。不过我们无需过多的考虑此策略有何优缺点，这仅仅是用来让你了解一些垃圾回收的工作方式。而且现在JVM大多也不用这种策略来进行垃圾回收。</p>
<p>以上我们简单的了解了一下垃圾回收的大致流程，那么接下来我们来了解一下垃圾回收器如何判断一个对象是否可回收。</p>
<h4 id="可达性分析算法（根搜索算法）"><a href="#可达性分析算法（根搜索算法）" class="headerlink" title="可达性分析算法（根搜索算法）"></a>可达性分析算法（根搜索算法）</h4><p>既然引用计数有缺点，那么可以采用其他的策略，Java采用了一种新的算法：可达性分析算法。</p>
<p>对象引用遍历从一组对象开始（GC Roots），沿着整个对象图上的每条链接，递归确定可到达（reachable）对象并生成一棵引用树，树的节点视为可达对象，反之视为不可达。之后垃圾回收器在进行垃圾回收的时候便可以回收那些不可达的对象。</p>
<p>我们以一个经典的例子来说明以上的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">	Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">	o2 = o1;</span><br><span class="line">	<span class="comment">//此为第五行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用一张图来表示到第三行为止时的示意图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1976147-b32d9b0150f26875.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第三行.png"></p>
<p>而到了第五行时，这个情况发生了变化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1976147-b28be23de6ef74f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第五行.png"></p>
<p>此时Obj2便是不可达对象，垃圾回收器在进行回收时便可以将Obj2的内存回收。以上是垃圾回收如确定可回收对象，接下来简要介绍一下垃圾回收的策略。</p>
<h4 id="内存回收策略"><a href="#内存回收策略" class="headerlink" title="内存回收策略"></a>内存回收策略</h4><ul>
<li>标记——清除（标记回收算法 或 Mark-Sweep）</li>
</ul>
<p>从堆栈和静态存储区出发，遍历所有引用，进而标记出所有存活对象，在整个标记过程中不会有回收工作发生。当标记工作完成时，清理动作才会开始。在清理过程中，没有标记的对象将会被释放。</p>
<p>这种策略的缺点很容易想到，分配内存的时候是连续的堆空间，但是在释放之后内存空间是不连续的，如果要分配较大的内存，这些内存碎片是不行的。如果想要得到连续的内存空间就得提前触发gc整理内存空间。</p>
<p>一种对Mark-Sweep进行优化的便是Mark-Compact（标记整理算法）。该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。这样就不会产生特别多的内存碎片了。</p>
<ul>
<li>停止——复制（复制算法）</li>
</ul>
<p>垃圾回收动作发生的同时，程序将会被暂停（gc stop the world）。复制算法将可用内存分为大小相等的两块，在垃圾回收器释放内存之前，这块内存内存活的对象都会被复制到另外一块内存中，之后将已使用的内存空间清理掉。这么做优点是不容易产生内存碎片，缺点也是显而易见的，存活对象非常多的话，其效率会降低。</p>
<ul>
<li>分代回收算法</li>
</ul>
<p>根据对象存活的生命周期将内存划分若干个不同的区域，一般划分为老年代（Old Generation）和新生代（Young Generation）。老年代的特点是每次gc时只有少量对象需要被回收，而新生代的特点是每次gc都有大量的对象需要被回收。这样就可以根据不同代的特点采取合适的策略，对于新生代采用copying算法，对于老年代使用Mark-Compact。</p>
<p>说真的，本来还想简介一下Davik或者ART虚拟机的，资料也找到了，但是从本篇来说不需要介绍那么多了，事实上甚至我觉得关于内存回收策略也不需要介绍……</p>
<h2 id="四种引用类型"><a href="#四种引用类型" class="headerlink" title="四种引用类型"></a>四种引用类型</h2><p>根据以上我们对于Java如何判定可回收对象的简介，我们可以对发生内存泄露的对象总结出以下特征：<br>1.在引用树上可达（被引用）<br>2.程序以后不会再使用这些对象了</p>
<h4 id="强引用（Strong-Reference）"><a href="#强引用（Strong-Reference）" class="headerlink" title="强引用（Strong Reference）"></a>强引用（Strong Reference）</h4><p>在第一点中我们说对象被引用，其实指的是被强引用。说的好像很高大上的样子，其实我们平时用的大多都是强引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>这类对象JVM自己抛OOM也不会通过GC回收这类对象。这是非常容易理解的，因为我们写代码需要一切是“可预料的”，如果我声明以上两个对象，竟然会莫名其妙的被JVM回收，那我只能和JAVA说再见了。当然了，我们也可以“提醒”gc回收该对象，比如将其引用置null—–&gt;p &#x3D; null;   list &#x3D; null。这样这两个对象便没有引用指向他了，下一次GC这两个对象便可以被回收了。</p>
<h4 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SoftReference&lt;Bitmap&gt; bm = <span class="keyword">new</span> SoftReference&lt;Bitmap&gt;(bmp);</span><br></pre></td></tr></table></figure>
<p>当一个对象只有软引用存在时，系统内存不足时会回收此对象。听起来还不错，但是在Android2.3以后，gc会很频繁，导致释放软引用的频率也很高，这无疑增加了程序维护的难度和不稳定性。所以如果有可替代的东西，就用别的来实现。</p>
<h4 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h4><p>发现就会被干掉的存在。</p>
<h4 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h4><p>不做介绍。</p>
<h2 id="MVP中的内存泄露"><a href="#MVP中的内存泄露" class="headerlink" title="MVP中的内存泄露"></a>MVP中的内存泄露</h2><p>前面铺垫了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;那么&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>长，终于说到重点了……是不是很激动，很期待？不管你是怎么想的，反正我是激动了~</p>
<p>在本篇中，其他可能引发内存泄露的东西，嗯，不分析。只分析耗时操作所引发的Activity或者其他V层实现类的内存泄露问题。熟悉MVP套路的同学应该会清除这么几点：<br>1.Model层获取数据<br>2.View层实现类执行回调的逻辑<br>3.Presenter层解除M和V的耦合，使M和V通过P层交互。</p>
<p>这么做肯定是有好处的，解除了M和V的耦合，他们俩互不感知，但是P层作为中间交互层不得不持有一个V层的引用和一个M层的实例。而当M层在进行一个耗时的操作时，由于P层是调用M层的逻辑实现一些功能，所以也可以将P层视为是一个耗时的操作。而且前面也说了，P层会持有一个V层的引用，如果在这个时候我们想要销毁这个Activity，那么这个Activity因为仍有P在持有Activity的引用从而导致其不会被回收，也就导致了内存泄露[** 注1 **]。恩，可能你看了我的纯文字描述有点头疼，没事，画张图你就好理解了（关系并不一定是这样的，但是方便理解）：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1976147-31151e6a1da05a5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="画张图"></p>
<p>可能你会有点奇怪，中间那个p咋整的啊，三个箭头指的你都晕了，但是MVP就是这么个套路啊~我们现在想要干的是释放activity的内存，那么按照我们之前说过的套路，虽然activity已经去掉了指向a的引用，但是p还没有去掉指向a的引用。那么显而易见的是如果presenter的生命周期长于activity的生命周期，恩，恭喜你内存泄露了。这种内存考虑值得我们更多的考虑[** 注2 **]</p>
<p>先放一个模拟MVP内存泄露的代码<br>首先是Model层的接口和实现类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Luo on 2016/9/30.</span></span><br><span class="line"><span class="comment"> * desc:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestModel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessageDelayed</span><span class="params">(Handler handler)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="keyword">package</span> com.xiasuhuei321.studyforrxjava;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Luo on 2016/9/30.</span></span><br><span class="line"><span class="comment"> * desc:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestModeImpl</span> <span class="keyword">implements</span> <span class="title">TestModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MESSAGE_DELAY = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageDelayed</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                handler.sendEmptyMessageDelayed(MESSAGE_DELAY, <span class="number">200000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>恩，上面我写的200000是我深深的怨念，本来写个2000，结果leakcanary这个检测内存泄露的工具貌似会调gc，结果成功回收了……尼玛我只要个现象啊……嗯，关于这一块回收掉的情况，我会在之后的情况里说明。接下来，放Presenter</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Handler;</span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Luo on 2016/9/30.</span></span><br><span class="line"><span class="comment"> * desc:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestPresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    TestView testView;</span><br><span class="line">    TestModel testModel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> TestModeImpl.MESSAGE_DELAY:</span><br><span class="line">                    TestPresenter.<span class="keyword">this</span>.testView.getMessage();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestPresenter</span><span class="params">(TestView testView)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.testView = testView;</span><br><span class="line">        testModel = <span class="keyword">new</span> TestModeImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        testModel.sendMessageDelayed(handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>View层的接口和Activity：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by Luo on 2016/9/30.</span></span><br><span class="line"><span class="comment"> * desc:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//activity</span></span><br><span class="line"><span class="keyword">import</span> android.content.Intent;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.LinearLayout;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.squareup.leakcanary.RefWatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">TestView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button btTest;</span><br><span class="line">    <span class="keyword">private</span> TestPresenter p;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        RefWatcher refWatcher = ExampleApplication.getRefWatcher(<span class="keyword">this</span>);</span><br><span class="line">        refWatcher.watch(<span class="keyword">this</span>);</span><br><span class="line">        p = <span class="keyword">new</span> TestPresenter(<span class="keyword">this</span>);</span><br><span class="line">        refWatcher.watch(p);</span><br><span class="line">        btTest = (Button) findViewById(R.id.bt_test);</span><br><span class="line">        btTest.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                p.getMessage();</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>, SecondActivity.class));</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;asdf&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>来看一下内存泄露检测的情况</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1976147-ceb78f52493dfb1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存泄漏"></p>
<p>结合代码我们可以发现的确是因为在presenter中因为持有testView的引用导致了MainActivity的内存泄露。</p>
<p>关于这种内存泄漏，我们利用以上对于Java内存回收、管理的策略的理解，可以这么解决：我们将presenter的生命周期和Activity的生命周期关联起来：</p>
<ul>
<li><p>在presenter中声明一个onDestroy()方法，在这个方法中将testView置为null，然后在presenter中凡是使用到testView的使用的，都判断一下是否为空。</p>
</li>
<li><p>在activity的onDestroy()方法中调用presenter.onDestroy()，同时也将activity持有的presenter置空。</p>
</li>
</ul>
<p>这样就可以解决MVP中由耗时操作和强引用导致的内存泄露的问题，是不是简单而优雅？（才怪）</p>
<p>当然了，以上方法里还有两个内存泄露我么有解决，那就是handler导致的activity内存泄露。handler在建立的时候会拿到当前线程的Looper，如果当前线程没有Looper就会报错，根据这个特性我猜测是因为取到线程这事导致的内存泄露。不过只是猜测，如果各位看官有知道这其中缘故还请告诉我。第二个是非静态内部类Handler所引发的内存泄露，Handler生命周期长于presenter，所以会引发presenter的内存泄露，你说我为啥不搞定？原理我都给你说了，刚好给你个机会去实践~（逃…）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1976147-525112dc21036ec1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="内存泄漏"></p>
<p>恩，刚和大佬<a target="_blank" rel="noopener" href="http://www.jianshu.com/users/8c4757fd3c5e/latest_articles">越越</a>聊了一下handler这事，他说了一个东西handler.removeCallbacks(null)，我把他放在presenter的onDestroy()里搞定了……</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.testView = <span class="keyword">null</span>;</span><br><span class="line">    handler.removeCallbacks(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种解决的方式使我们根据自己的经验得出的最简单粗暴的解决方式，这样能有效的避免因testView持有activity的引用而导致的内存泄露问题。本来想试一下Rxjava+MVP，然后在对应的生命周期里unsubscribe()来解决内存泄漏的问题，但是用leakcancry检测一直会报和上面一样的内存泄露，而我试了各种方法都没能解决。虽然在leakcancry的android sdk所导致的内存泄露中貌似找到了这个</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1976147-c50908147483dc0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sdk内存泄露"></p>
<p>问题是我的手机系统版本是6.0.1，按照他这个来说应该是被修复了的。而且很奇怪的一点是我在startActivty跳转到第二界面并finish自身才会报之前的内存泄露，不然的话直接返回桌面并finish是不会有内存泄露的，暂时没弄懂是什么状况，如果有人知道是为什么请务必告诉我，谢谢！</p>
<p>因为这个问题没解决，暂时不往下写了，但是我以上写的原理肯定是对的。我没能解决的问题那是因为我现在还不是Android系统的好队友，嗯，猪队友吧，先去搞会Android压压惊。关于注1,2我想说的其实是一件事：其实有的时候这种内存泄漏是** 可以接受 <strong>的，比如有时可能这种内存泄露所引发的后果只是</strong> 本次GC **无法回收这块内存，但是下一次呢？下一次耗时操作过了，这块内存没有引用指向他了，是可以被回收的。但是这也取决于你，你要是觉得不能忍受，那就麻溜的修复这些东西。</p>
<p>如果你对我发现的这个问题有兴趣，问题代码已经放在了：<br><a target="_blank" rel="noopener" href="https://github.com/ForgetAll/StudyForRxJava">demo地址</a><br>一不小心上传了配置文件……</p>
<hr>
<p>以下为我写文时的参考资料，感谢各位大神无私分享的精神！</p>
<p>** java回收机制： **</p>
<p><a target="_blank" rel="noopener" href="http://jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">杰风居-理解Java垃圾回收机制</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/laoyangHJ/articles/java_gc.html">老杨HJ-详细介绍Java垃圾回收机制</a></p>
<p>《Thinking in Java》&amp; 《Effective Java》</p>
<p>** Android内存泄露分析： **</p>
<p><a target="_blank" rel="noopener" href="http://duanmo.me/2016/04/17/memory-leak-summary/#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BB%8B%E7%BB%8D">Android内存泄露总结</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/3009">箫鉴哥-Android内存泄漏总结</a></p>
<p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&mid=400021278&idx=1&sn=0e971807eb0e9dcc1a81853189a092f3&scene=0&key=b410d3164f5f798eafd870697d352ac86e0e54b9605b5fcd2c6a62268c16080ee291069627f13ed906cc2f39706b6a54&ascene=0&uin=NzY0MTg2ODU=&devicetype=iMac+MacBookPro11,1+OSX+OSX+10.10.5+build(14F27)&version=11000003&pass_ticket=nhSGhYD4LC9FWvUPv26Y7AdIzqEDu8FTImf2AKlyrCk=">QQ空间终端开发团队-Android GC那点事</a></p>
<p><strong>我同学写的关于MVP中P造成的内存泄露的花式解决：</strong></p>
<p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/d9f4c8219a65">iamxiarui-Android：聊聊 MVP 中 Presenter 的生命周期</a></p>
<p><strong>最后还要感谢一下square的开源项目:</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">内存泄漏检测工具</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Android/" rel="tag"># Android</a>
              <a href="/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/" rel="tag"># 内存泄漏</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/c0cca39aa548a0a40706f8ca15d94c69/" rel="prev" title="手把手教你打造支持手势放大缩小的ImageView">
      <i class="fa fa-chevron-left"></i> 手把手教你打造支持手势放大缩小的ImageView
    </a></div>
      <div class="post-nav-item">
    <a href="/4acbd7ecac975b9ce89d473235e511ad/" rel="next" title="Android之观察者模式">
      Android之观察者模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%99%E5%9C%A8%E5%89%8D%E9%9D%A2"><span class="nav-number">1.</span> <span class="nav-text">写在前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#finalize"><span class="nav-number">2.0.1.</span> <span class="nav-text">finalize()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">Java内存分配策略</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-number">4.</span> <span class="nav-text">Java内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">4.0.1.</span> <span class="nav-text">引用计数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%88%E6%A0%B9%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">4.0.2.</span> <span class="nav-text">可达性分析算法（根搜索算法）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">4.0.3.</span> <span class="nav-text">内存回收策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.</span> <span class="nav-text">四种引用类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strong-Reference%EF%BC%89"><span class="nav-number">5.0.1.</span> <span class="nav-text">强引用（Strong Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="nav-number">5.0.2.</span> <span class="nav-text">软引用（Soft Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="nav-number">5.0.3.</span> <span class="nav-text">弱引用（Weak Reference）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="nav-number">5.0.4.</span> <span class="nav-text">虚引用（Phantom Reference）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2"><span class="nav-number">6.</span> <span class="nav-text">MVP中的内存泄露</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">LJ</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">82</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">38</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">LJ</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '76eeb7f12824012f27fe',
      clientSecret: '88d321f6332401c447afecc2f4069556536e6eab',
      repo        : 'ForgetAll.github.io',
      owner       : 'ForgetAll',
      admin       : ['ForgetAll'],
      id          : 'ed3225319b0fa0b3bc9c358d8880ee4c',
        language: '',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
